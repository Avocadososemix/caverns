package BinarySpacePartition;

import GameLogic.Tile;
import GameLogic.Coordinates;
import GameLogic.Level;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.concurrent.ThreadLocalRandom;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author lkaranko
 */
public class BinarySpacePartition {

    private int levelWidth, levelHeigth;
    private final int timesSplit;
    private final int BSP_MinSplit, BSP_MaxSplit;
    private Level level;
    private Room[] dugRooms;
    public double sectorShown0, sectorShown1;

    public BinarySpacePartition(int timesSplit) {
        this.timesSplit = timesSplit;
        this.BSP_MinSplit = 30;
        this.BSP_MaxSplit = 70;
    }

    /**
     * This method initializes the process of applying binary space partitioning
     * to the level. The SectorShown parameters define what is the size of the
     * sector on which BSP is used on the level.
     * @param level
     * @return 
     */
    public Level generateBSP(Level level) {
        this.level = level;
        sectorShown0 = 0.5;
        sectorShown1 = 0.5;
        levelHeigth = level.getSizeY();
        levelWidth = level.getSizeX();
        ArrayList<Room[]> pair = splitLevel();
        connectRooms(pair);
        return level;
    }

    /**
     * This class contains the Binary Space Partitioning logic. A level is
     * partitioned into smaller and smaller pieces that will all
     * contain rooms/empty space. Bisected regions are saved as Region-pairs,
     * which are later used to create tunnels that connect the rooms.
     *
     * @return
     */
    public ArrayList<Room[]> splitLevel() {
        ArrayList<Room> regions = new ArrayList<>();
        ArrayList<Room[]> regionsPairs = new ArrayList<>();
        Room entireLevel = new Room(new Coordinates(0, 0), new Coordinates(level.getSizeX(), level.getSizeY()));
        regions.add(entireLevel);
        ArrayList<Room> tempList = regions;
        //Map space is divided
        for (int i = 0; i < timesSplit; i++) {
            tempList = new ArrayList<>();
            //Selecting last region in RegionList
            for (Room region : regions) {
                //initializing new Rooms
                Room region1, region2;
                //Choose split size randomly
                int split = (int) ThreadLocalRandom.current().nextInt(BSP_MinSplit, BSP_MaxSplit + 1);
                //If the split number is odd, split vertically
                if ((i % 2) != 0) {
                    int splitValue = (int) (((region.getWidth()-region.x0()) * split) / 100.0);
                    region1 = new Room(region.getTopLeftCorner(), new Coordinates(region.getTopLeftCorner().getCoordX()
                            + splitValue, region.getHeigth()));   //change this to change room wall thickness
                    region2 = new Room(new Coordinates(region1.getWidth(), region.y0()), //change this to change room wall thickness
                            new Coordinates(region.getWidth(), region.getHeigth()));
                } else {
                    //split horizontally
                    int splitValue = (int) (((region.getHeigth()-region.y0()) * split) / 100.0);
                    region1 = new Room(region.getTopLeftCorner(), new Coordinates(region.getWidth(),
                            region.getTopLeftCorner().getCoordY() + splitValue)); //change this to change room wall thickness
                    region2 = new Room(new Coordinates(region.x0(), region1.getHeigth()), //change this to change room wall thickness
                            new Coordinates(region.getWidth(), region.getHeigth()));
                }
                tempList.add(region1);
                tempList.add(region2);
                Room[] pair = new Room[]{region1, region2};
                regionsPairs.add(pair);
            }
            regions.clear();
            regions.addAll(tempList);
        }
        digRooms(tempList);
        return regionsPairs;
    }

    /**
     * All the rooms generated by the BSP are added into the level with this class.
     * The class also sets the boundaries for BSP to preserve some of the level
     * from being room simply rooms.
     * @param rooms 
     */
    public void digRooms(ArrayList<Room> rooms) {
        Coordinates topLeft = new Coordinates(0,0);
        Coordinates botRight = new Coordinates((int) Math.floor(levelWidth*sectorShown0),
                (int) Math.floor(levelHeigth*sectorShown1));
        rooms.forEach((room) -> {
            level.fillSectionWithRooms(room.dig(), topLeft, botRight);
        });
    }

    /**
     * This class calls the connectRooms method in the level being processed,
     * adding tunnels that connect room pairs. Rooms are connected from their
     * centers to their opposing pairs. Rooms that were generated by the BSP-algorithm
     * during its recursive loops were still saved as room pairs to generate
     * additional crisscrossing corridors that connect all the rooms in the level.
     * @param roomPairs 
     */
    public void connectRooms(ArrayList<Room[]> roomPairs) {
        level.connectRooms(roomPairs);
    }
}
